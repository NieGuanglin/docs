[TOC]

# 管道

管道就是在两个进程之间建立一条**单向**的通道，其实是一段**缓存**，它会将前一个命令的输出，作为后一个命令的输入。

管道如果要实现进程间相互通信，需要创建两个通道才行。这种通信方式效率低，不适合进程间频繁地交换数据。

无论是匿名管道，还是命名管道，传输的数据都是缓存在内核中。

## 匿名管道

匿名管道的**通信范围是存在比较近亲缘关系的进程**。因为它们需要fork来复制父进程的管道文件描述符，来达到通信的目的。**它是命令行中最常用的模式。**

## 命名管道

命名管道**在不相关的进程间也可以相互通**信。因为命名管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。



# 消息队列

**很少使用，因为有太多的用户级别的消息队列，功能更加强大。**

消息队列的模式可以解决进程间频繁交换数据的问题。a进程要给b进程发送消息，a进程把数据放在对应的消息队列后就可以正常返回，而不像管道那样，必须等b进程接收后才能返回。b进程需要的时候再去读取数据就可以了。

消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体。消息的发送方和接收方要约定好消息体的数据类型，所以每个**消息体都是固定大小的存储块，不像管道是无格式的字节流数据**。如果进程从消息队列中读取了消息体，内核就把这个消息体删除。

**消息队列生命周期随内核，如果没有释放消息队列，它会一直存在。而匿名管道的生命周期，是随进程的创建而创建，随进程的结束而销毁。**

不足：

- 通信不及时。
- 不适合比较大的数据的传输，因为消息体的大小有上限限制，而且队列所包含的全部消息体的数量也有上限。
- 存在用户态与内核态之间的数据拷贝开销。



# 共享内存

**共享内存加信号量是常用的模式**。

每个进程都有自己独立的虚拟地址空间，不同进程的虚拟地址空间映射到不同的物理内存中去。这样，不同进程的同一个虚拟内存地址，其实对应的是不同的物理内存地址，对于数据的增删改查互不影响。

如果拿不同进程的虚拟地址空间的一部分，映射到相同的物理内存中。这样，一个进程写入的数据，另一个进程马上就能读到，都不需要来回拷贝。大大提高了进程间通信的速度。



# 信号量

使用共享内存，带来了新的问题，那就是多个进程同时操作同一个共享内存，很可能造成冲突。信号量，使得共享的资源同一时刻只能被一个进程访问。因此，共享内存和信号量往往要配合使用。

**信号量其实是一个计数器，主要用于实现进程间的互斥与同步，而不是用于存储进程间通信的数据。**

## P操作与V操作

信号量可以表示某种资源的数量，它定义了两种原子操作：

1. P操作，申请资源操作。信号量-1，相减后<0，表明资源被占用，进程阻塞等待；相减后>=0，表明还有资源可用，进程可继续执行。
2. V操作，归还资源操作。信号量+1，相加后<=0，表明有阻塞中的进程，会把该进程唤醒；相加后>0，表明没有阻塞中的进程。

P操作用在进入共享资源之前，V操作用在离开共享资源之后，它们必须成对出现。

### 互斥

信号量初始化为1，可以保证共享内存在任何时刻只有一个进程在访问。

两个进程都需要分别执行P，V操作。

### 同步

信号量初始化为0，可以保证先运行执行了V操作的a进程，然后再运行执行了P操作的b进程。因为即使先运行了b进程，它也会因为没有资源而阻塞，必须等到a运行。

b进程只执行P操作，a进程只执行V操作。

### 信号量回退

信号量是整个Linux可见的全局资源，而不是某个进程独占的资源。如果一个进程通过P操作拿到了一个信号量，但是不幸退出了，如果没有来得及归还这个信号量，可能所有的进程都阻塞了。于是，Linux有一种机制叫做SEM_UNDO，每一个操作都会保存一个反向操作。当某个进程异常退出的时候，这个进程做的所有的操作都会回退，从而保证其他进程可以正常工作。



# 信号

上面的进程间通信，都是常规状态下的工作模式。**对于异常状态下的工作模式，就需要用“信号”的方式来通知进程。**

Linux命令：

```shell
$ kill -l
1)SIGHUP	2)SIGINT	3)SIGQUIT	4)SIGILL	5)SIGTRAP
...
# 查看信号的含义
$ man 7 signal
```

## 发送信号

### 发出信号的场景

- 终端组合键：ctrl+c产生SIGINT信号；ctrl+z产生SIGSTP信号。
- 硬件异常产生信号：执行除以0的指令，cpu就会异常，发送SIGFPE信号；进程访问非法内存，内存管理模块产生异常，发送SIGSEGV信号。
- 内核给进程发信号：向读端已经关闭的管道写数据时，产生SIGPIPE信号；子进程退出时，给父进程发送SIGCHLD信号。
- 通过kill系统调用发信号。

### **中断与信号**

- 处理函数位置不同。
  - 中断要注册中断处理函数，中断处理函数是在内核驱动里面。
  - 信号注册信号处理函数，信号处理函数是在用户态进程里面。
- 对于硬件触发的，无论中断还是信号，肯定都是先到内核，内核对于中断和信号的处理方式不同。
  - **中断是完全在内核里面处理完毕**。
  - 信号是将信号放在对应进程task_struct中与信号相关的数据结构里面，然后**等待进程在用户态去处理**。当然，有些严重的信号，内核会把进程干掉。
- 严重程度不同。
  - 中断影响的是整个系统，一旦中断处理有bug，可能整个Linux都挂了。
  - 信号影响的往往是某一个进程，处理慢了，甚至错了，也不过是这个进程被干掉。

## 处理信号

### 处理方式

- 执行默认操作。Linux为每种信号都规定了默认操作。如：

  - Term

    终止进程

  - Core，即Core Dump

    终止进程后，通过Core Dump将当前进程的运行状态保存在文件里，方便后续进行问题分析

- 捕捉信号。可以为信号注册一个信号处理函数，当信号发生时，就执行相应的信号处理函数。在每个进程的task_struct里面，都有一个sighand指向struct sighand_struct，里面有一个数组，下标是信号，内容是信号处理函数。

- 忽略信号。忽略信号，不做任何处理。不过有两个信号是应用进程无法捕捉和忽略的，即SIGKILL和SIGSTOP，用于在任何时候结束或中断某一进程。

### 处理过程

1. 进程A调用系统调用进入内核，用户态寄存器的信息保存在pt_regs里面，它包含了用户态栈，栈顶指针下一条指令Line A。
2. 其他进程给进程A发信号，其实就是将信号放在进程A的task_struct中与信号相关的数据结构中，并且给线程设置TIF_SIGPENDING。
3. 试图唤醒整个线程，把状态设置为TASK_RUNNING，然后放在运行队列中。线程被调度执行，当发现有信号到来时，就返回当前正在执行的系统调用，并返回一个错误表示系统调用被（信号）中断了。返回系统调用之前，修改pt_regs信息：插入一个栈帧，里面保存旧的pt_regs；当前pt_regs里的栈顶指针指向信号处理流程。
4. 返回用户态，处理信号。
5. 由于前面对栈帧的修改，会调用指定的系统调用进入内核。
6. 内核恢复旧的pt_regs，最终返回用户态，回到Line A。



# socket

**前面的管道，消息队列，共享内存，信号量，信号都是在同一台主机上进行进程间通信。**

**如果想跨网络与不同主机上的进程通信，就需要socket。socket不仅可以跨网络与不同主机的进程通信，还可以在同一台主机上与进程通信。**

## socket系统调用

二层到四层都是在Linux内核里面处理的，应用层都是用户态的。内核里面对于网络包的处理是不区分应用的。从四层再往上，就需要区分网络包发给哪个应用。在传输层的TCP和UDP协议里面，都有端口的概念，不同的应用监听不同的端口。

应用层和内核互通的机制，就是通过socket系统调用。socket属于操作系统的概念，而非网络协议分层的概念。操作系统选择对于网络协议的实现模式是，二到四层的处理代码在内核里面，七层的处理代码让应用自己去做，两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，它就是socket。

分类：

- 跨主机TCP字节流通信。
- 跨主机UDP数据报通信。
- 本地字节流通信。
- 本地数据报通信。

创建socket的系统调用：

```c
int socket(int domain, int type, int protocal)
```

- domain代表通信域：AF_INET，AF_INET6，AF_UNIX。

- type代表通信特性：SOCKET_STREAM，SOCKET_DGRAM，SOCKET_RAW。
- protocal代表通信协议：现在基本废弃，因为前两个参数就可以指定完成。一般写0即可。


[TOC]

# 文件系统分层

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82.png" />

- 系统调用层：在应用层，进程在进行文件读写操作时，可以通过系统调用，如sys_open，sys_read，sys_write等。
- 虚拟文件系统层：Linux可以支持多达数十种不同的文件系统，它们的具体实现各不相同，因此Linux内核向用户空间提供了虚拟文件系统这个统一的接口，来对文件系统进行操作。它提供了常见的文件系统对象模型，例如inode，dentry，mount等，以及操作这些对象的方法，例如inode operations，dentry operations，file operations等。
- 具体文件系统层：虚拟文件系统对接真正的文件系统，比如ext2，ext3，ext4等文件系统。
- 块设备驱动层：操作磁盘块设备，需要通过驱动程序。

## 文件系统分类

1. 基于磁盘的文件系统，把数据直接存储在计算机本地挂载的磁盘中。如Ext4，XFS，OverlayFS等。
2. 基于内存的文件系统，不需要任何磁盘分配存储空间，但会占用内存。/proc用于暴露内核的可配置参数给用户，/sys用于向用户空间导出层次化的内核对象。
3. 网络文件系统，用来访问其他计算机数据的文件系统，如NFS，SMB，iSCSI等。



# ext文件系统

## 常见文件的种类

- -：表示普通文件。
- d：表示目录。
- c：表示字符设备文件。
- b：表示块设备文件。
- s：表示套接字socket文件。
- l：表示符号连接，也即软链接，通过名字指向另外一个文件。



## inode与块存储

- 块存储

  每一层的盘片里分多个磁道，每个磁道分多个扇区，每个扇区是512byte。所以硬盘以512个字节大小的块进行管理，文件系统又以4Kb为大小划分逻辑块。

- **inode**

  inode，即index node。用来记录文件的元信息，比如inode编号，文件大小，访问权限，atime，ctime，mtime，数据在磁盘的位置等等。**索引节点是文件或目录的唯一标识，它们之间一一对应，也同样被存储在硬盘上，同样占用磁盘空间。**

  - atime：access time，最近一次**访问文件**的时间。访问不代表修改，可能只是读，就会改变atime。
  - ctime：change time，最近一次**更改inode**的时间。修改inode，有可能修改的是用户和权限，没有修改数据部分，就会改变ctime。
  - mtime：modify time，只有**数据被修**改了，才会改变mtime。

- inode映射为文件

  - ext2和ext3中

    <img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-ext3-inode%E4%B8%8E%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E6%98%A0%E5%B0%84.png" />

    inode中的数组，索引项0-11直接保存了块的位置。索引项12指向的块中，不存放数据块，而是存放数据块的位置，这个块称为间接块。索引项13指向的块中，存放间接块的位置，称为二次间接块。索引项14指向的块中，存放二次间接块的位置，称为三次间接块。

  - ext4中

    在ext3中，大文件需要多次读取硬盘才能找到对应的块，访问速度较慢。ext4为了解决这个问题，引入了新的概念，Extents。它可以表示连续的块。

- inode映射为目录

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/3%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-inode%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E6%98%A0%E5%B0%84.png" />

  目录本身也是一个文件。inode既可以映射为文件，也可以映射为目录。只不过，和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的inode信息。

  当目录下有很多很多的文件或目录时，怎么快速定位指定的文件或目录呢？

  如果在inode中设置EXT3_INDEX_FL标志，则目录文件的块的组织形式将发生变化。将子文件和子目录进行分组，再存放在不同的块中。查找时，先根据哈希定位到块，再在块内去找inode。这些inode还是老样子，要么指向文件内容数据块，要么指向目录内容数据块。

## inode位图与块位图

​	1个块保存inode位图，inode位图中的每一位，表示inode是否使用的状态。

​	1个块保存块位图，块位图中的每一位，表示块是否使用的状态。

​	一个块共4Kb，即4 * 1024 * 8 = 2 ^ 15个数据块，也即最大可以表示2 ^ 15 * 4 * 1024 = 2 ^ 27 byte，也就是128Mb。

## 文件系统的格式

- 总体格式

  引导块 + 一系列的块组。

  引导块：如果是一个启动盘，需要预留1kb区域作为启动引导区。

- 单个块组格式

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%80%BB%E4%BD%93%E6%A0%BC%E5%BC%8F.png" />

  超级块（1块）+ 块组描述符表（多块）+ 块位图（1块）+ inode位图（1块）+ inode列表（多块）+ 数据块（多块）

  - 超级块：对整个文件系统的情况进行描述，比如，整个文件系统一共有多少个inode，一共有多少个块，每个块组多少个inode，每个块组多少个块等。
  - 块组描述符表：对文件系统中各个块组的状态进行描述，比如块组中空闲inode和块的数目等。

- 超级块与块组描述符表的备份策略

  超级块和块组描述符表都是全局信息，而且这些信息很重要。如果这些数据丢失了，整个文件系统都打不开了，这比一个文件的一个块损坏更严重。这两部分都需要备份，但是备份策略不同。

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E8%B6%85%E7%BA%A7%E5%9D%97%E4%B8%8E%E5%9D%97%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E7%9A%84%E5%A4%87%E4%BB%BD.png" />

  - 超级块：由于超级块不是很大，所以就算备份多了也没有太多问题。超级块的副本，只会保存在块组索引为0，3，5，7的整数幂里。如，0，1，3，5，7，9，25，27等等。
  - 块组描述符表：如果块组描述符表像超级块一样，都保存完整的备份，就很浪费空间了。所以引入**元块组**的概念。
    1. 将块组以64个为一组进行分组，称为元块组。一个元块组描述64个块组。元块组分别备份自己的部分。比如0-63块组，它们在第一个元块组中被描述，它们就只备份第一个元块组的块组描述符表。64-127块组，它们就只备份第二个元块组的块组描述符表。
    2. 同一个元块组，只备份三份块组描述符表，分别位于它描述的元块组的第一个，第二个和最后一个。比如0，1，63号块组中，就各保存有一个块组描述符表。

## dentry与软链接，硬链接

- **dentry**

  即directory entry。目录项，用来记录文件的名字，inode的指针以及与其他目录项的层级关联关系。**dentry可以定位inode，但它与inode不同，dentry是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。**

- **硬链接**

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E7%A1%AC%E9%93%BE%E6%8E%A5.png" />

  **多个dentry指向同一个inode。每种文件系统都有各自的inode，inode是不可以跨越文件系统的，所以硬链接是不能跨文件系统的。由于多个dentry都是指向同一个inode，所以只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。**

- **软链接**

  ![7文件系统-软链接](/Users/nieguanglin/pics/os/file-manager/7文件系统-软链接.png)

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/os/file-manager/7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E8%BD%AF%E9%93%BE%E6%8E%A5.png" />
  
  **软链接相当于重新创建了一个文件，这个文件有独立的inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件。软链接是可以跨越文件系统的，甚至目标文件删除了，软链接文件还是在的，只是指向的文件找不到了而已。**

## 文件描述符

- **文件描述符**

  **每一个进程的task_struct中，都有一个指针files，类型是files_struct。files_struct里面有一个字段是文件描述符列表，该进程每打开一个文件， 就会在这个列表中分配一项，列表的下标就是文件描述符。文件描述符，就是用来区分一个进程打开的多个文件的。它的作用域就是当前进程，出了当前进程这个文件描述符就没有意义了。**

  **文件描述符列表的每一项都是一个指向struct file的指针，也就是说，每打开一个文件，都会有一个struct file对应。struct file又与dentry关联，dentry再与inode关联。最终，inode指向文件或目录。**

  **对于任何一个进程，默认情况下，文件描述符0表示stdin标准输入，文件描述符1表示stdout标准输出，文件描述符2表示stderr标准错误输出。另外，再打开的文件，都会从这个列表中找一个空闲位置分配给它。**

- dentry cache的数据结构

  Linux为了提高dentry的处理效率，设计与实现了目录项高速缓存dentry cache，简称dcache。它主要由两个数据结构组成：

  1. 哈希表dentry_hashtable：dcache中的所有dentry都通过它的d_hash指针链到相应的dentry哈希链表中。
  2. 未使用的dentry链表s_dentry_lru：dentry通过它的d_lru指针链入lru链表中。长时间不使用，就应该释放。

- struct file与dentry的区别

  file结构是一个文件打开以后才创建，dentry是放在一个dcache里面，文件关闭了，它依然存在，所以它可以更长期地维护内存中的文件的表示和硬盘上的文件的表示之间的关系。

## 文件的I/O操作

根据是否使用内存做缓存，可以把文件的I/O操作分为两种。无论哪种，cpu都只能直接访问内存，所以都必须通过内存获取硬盘数据。

- 直接I/O

  应用程序直接访问磁盘数据，不经过内核缓冲区，从而减少了在内核缓存与用户程序之间数据复制。

  - 读

    用户态调用系统调用；内核不检查缓冲区，直接从硬盘读到内核空间；从内核空间复制到用户空间。

  - 写

    用户态调用系统调用；数据从用户态空间复制到内核态空间；内核不考虑写入时机，直接写入硬盘。

- 缓存I/O

  大多数文件系统的默认I/O操作都是缓存I/O。

  - 读

    用户态调用系统调用；内核会先检查内核的缓冲区有没有需要的数据，如果已经缓存了，那就直接从缓存中返回，否则从磁盘中读取，并缓存在内核的缓冲区中；从内核空间复制到用户空间。

  - 写

    用户态调用系统调用；数据从用户态空间复制到内核态空间；这时对于用户程序来说，写操作已经完成。至于什么时候真正写入到磁盘由操作系统决定，除非显式地调用了sync同步命令。

    - 触发回写的场景
      1. 缓存的数据太多的时候。
      2. 用户主动调用sync的时候。
      3. 内存十分紧张，以至于无法分配页面的时候。
      4. 脏页已经更新了较长时间，时间上超过了timer，需要及时回写，保持内存和磁盘上数据的一致性。

- 文件的缓存是如何被组织进struct file的？或者，文件的哪些数据已经被放到缓存中？

  缓存以页为单位放在内存里面。file中有一个字段，是一棵树，用来保存所有与这个文件相关的缓存页。查找的时候，需要根据数据在文件中的偏移量找到对应的页面，而**基数树radix tree**这种数据结构能够快速根据一个长整形查找到相应的对象。所以缓存页就放在基数树radix tree里面。
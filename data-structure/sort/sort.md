[TOC]

# 基于比较的排序算法

## 冒泡排序

### 算法要点

外层循环表示：把数组从头到尾扫描一遍。

内层循环表示：从数组尾到外层索引游标，依次相邻元素对比，前面的大于后面的，则交换。

### 优化点

如果某次内层循环（也即冒泡过程），没有交换任何元素。那就说明数组已经处于有序状态，可以直接退出。

### 时间复杂度

最好情况下，数据已经是有序的了，只需要一次冒泡操作，所以最好时间复杂度是O(n)。外层循环O(1) + 内层循环O(n) = O(n)。

最坏情况下，数据刚好是倒序的，需要进行n次冒泡操作，所以最坏时间复杂度是O(n^2)。

平均情况下：

有序度，是数组中具有有序关系的元素对的个数。

完全有序的数组的有序度，叫做满有序度，n个元素的数组，满有序度就是n*(n-1)/2。

逆序度，是数组中具有无序关系的元素对的个数。

逆序度 = 满有序度 - 有序度。

**排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。冒泡排序包含两个操作，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度。**

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n\*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n\*(n-1)/2，就不需要进行交换。可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。

平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。(夹逼准则)

### 空间复杂度

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

### 稳定性

稳

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，这样相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。



## 插入排序

### 算法要点

外层循环表示：把数组从头到尾扫描一遍。

如果前面的元素大于后面的元素，进入内层循环。内层循环表示：从内层循环游标到0，或者到内层元素不大于新出现的“后面的元素”，元素依次向后挪动。内层循环退出时的游标索引，就是“后面的元素”的位置。

### 优化点

希尔排序。

### 时间复杂度

最好情况下，数据已经是有序的了，只需要全部比较一遍，所以最好时间复杂度是O(n)。外层循环O(n) + 内层循环O(1)=O(n)。

最坏情况下，数据刚好是倒序的，需要进行n次插入搬运操作，所以最坏时间复杂度是O(n^2)。

平均情况下：

在数组中插入数据的平均时间复杂度：1/(n+1) * (n + (n-1) + ... + 2 + 1 + 0) = 1/2*n，即O(n)。

对于插入排序来说，**每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)。**

### 空间复杂度

插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

### 稳定性

稳

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面（也就是内层循环的执行条件里，大于，才挪动），这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。



## 比较排序

### 算法要点

外层循环表示：把数组从头到尾扫描一遍。

内层循环表示：从外层循环游标到数组末尾，寻找最小元素的索引。循环结束时，最小元素索引不等于外层循环游标，则交换。

### 时间复杂度

不管原来的顺序是什么，都要从无序数组中找到最小值，而最小值只能通过全部比较一次才能得到。

最好时间复杂度是O(n^2)。

最坏时间复杂度是O(n^2)。

平均时间复杂度为 O(n^2)。

### 空间复杂度

比较排序算法的空间复杂度是 O(1)，是一个原地排序算法。

### 稳定性

不稳

举例： [2，二，1] ，结果是[1，二，2]。



## 归并排序

### 算法要点

先切分，再排序。最后从最小的单位逐级返回，每次返回都是有序的。

### 时间复杂度

假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。

```
//n=1时，只需要常量级的执行时间，所以表示为C。
T(1) = C
//n>1
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     ...
     = 2^k * T(n/2^k) + k*n
```

n/2^k表示：分解后的数据规模。

k表示：把数据规模分解到1时的分解次数，故当算法完成，数据规模分解到1，此时n/2^k=1。

当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。所以归并排序的时间复杂度是 O(nlogn)。



归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的。

最好时间复杂度是O(nlogn)。

最坏时间复杂度是O(nlogn)。

平均时间复杂度为 O(nlogn)。

### 空间复杂度

尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

### 稳定性

归并排序是一个稳定的排序算法。



## 快速排序

### 算法要点

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/data-structure/sort/快速排序-分区函数演示.png">

<img src="/Users/nieguanglin/docs/pics/data-structure/sort/快速排序-分区函数演示.png" alt="快速排序-分区函数演示" style="zoom:100%;" />

边切分，边确保大致有序（左边小于中间元素，右边大于中间元素）。

最后从最小的单位逐级返回，每次返回都是有序的。

### 时间复杂度

最好情况下：

选择的 pivot 都很合适，正好能将大区间对等地一分为二，那快排的时间复杂度递推求解公式跟归并是相同的。所以，最好情况下，快排的时间复杂度也是 O(nlogn)。

```
//n=1时，只需要常量级的执行时间，所以表示为C。
T(1) = C
//n>1
T(n) = 2*T(n/2) + n
```

但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。



最坏情况下：

如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。

```
//以1,3,5,6,8举例，递归调用quickSort2几次呢？
quickSort2(arr, 0, 4)
quickSort2(arr, 0, 3)
quickSort2(arr, 0, 2)
quickSort2(arr, 0, 1)
quickSort2(arr, 0, 0)//最后一次调用，触发递归结束条件，也就是没有调用partition
//共n次

//平均每次分区，扫描几个元素呢？
//0, 1, 2, 3 =》 共4个
//0, 1, 2 =》 共3个
//0, 1 =》 共2个
//0 =》 共1个
//共0个
//[(n-1 + 0) * n / 2] / n，即(n-1)/2

综上，最坏情况下，退化为O(n^2)。
```



平均情况下：

假设每次分区，两个区间的长度比是1：k。

快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h∗n ，也就是说，时间复杂度就是 O(h∗n)。（这是估算的情况，在每层的所有区间都还大于1的时候，每一层遍历的数据个数之和才是n。）

暂时假定k=9。

我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10。

```
最短路径下：
n, n/10, n/10^2, ..., 1
所以路径长度是：log以10为底的n。

最长路径下：
n, 9n/10, (9^2 * n)/10^2, ..., 1
所以路径长度是：log以10/9为底的n。
```

所以，遍历数据的个数总和就介于 n(log以10为底的n)和 n(log以10/9为底的n)之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。

当 k=99 的时候。

树的最短路径就是 log以100为底的n，最长路径是 log以100/99为底的n。尽管底数变了，但是时间复杂度也仍然是 O(nlogn)。

也就是说，对于 k 等于 9，99，甚至是 999，9999……，只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(nlogn)。所以，从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)。

### 空间复杂度

如果不考虑空间复杂度，partition分区函数的实现非常简单，但是会需要额外的内存空间。

所以巧妙地设计分区函数，可以使空间复杂度为O(1)。

### 稳定性

举例：[1，一]，结果是[一， 1]。



## 堆排序

### 算法要点

- 建堆

  对下标从(n/2 - 1) 开始到0的数据进行堆化，下标是n/2到n-1的节点是叶子节点，不需要堆化。实际上，对于完全二叉树来说，下标从n/2到n-1的节点都是叶子节点。

  - 堆化

    重复进行自上向下堆化。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。

    从0号下标存储数据的数组，i号元素的左子节点：2\*i + 1；右子节点：2\*i + 2；父节点：(i -1)/2。

- 排序

  建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。

  一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。

  - 堆化

    重复进行自上向下堆化。

### 时间复杂度

- 建堆

  每个节点需要比较和交换的节点个数，求和，就是建堆的时间复杂度。

  每个节点需要比较和交换的节点个数，与该节点的高度，成正比。

  所以，每个节点的高度求和，就是建堆的时间复杂度。

  于是，**分层，分别计算节点的高度**：

  S1 = 1\*h + 2\*(h-1) + ... + 2^(h-1)\*1

  把公式左右都乘以 2，就得到另一个公式 S2。我们将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。

  S2 =            2\*h + ... 2^(h-1)*2 + 2^h\*1

  S = S2 - S1= -h + 2 + 2^2 + ... + 2^(h-1) + 2^h = 2^(h+1) - h -2

  h = log以2为底的n，S = 2n - log以2为底的n -2。

  所以建堆的时间复杂度是O(n)。

- 排序

  一个包含 n 个节点的完全二叉树，树的高度不会超过 log2n。堆化的过程是顺着节点所在路径比较交换的，所以**一次**堆化的时间复杂度跟树的高度成正比，也就是O(logn)。

  所以排序的时间复杂度是O(nlogn)。

综合建堆与排序，堆排序整体的时间复杂度是 O(nlogn)。

### 空间复杂度

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法，O(1)。

### 稳定性

堆排序不是稳定的排序算法，因为在**排序的过程**，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

举例：对数组[1, 一]升序，建堆过程仍然是稳定的，但是排序过程会把原本在前面的1先弹出到最后，导致不稳定。（小顶堆触发调整的条件是：**大于**；大顶堆触发调整的条件是：**小于**。）

### 缺点

与快速排序相比：

- 堆排序数据访问的方式没有快速排序友好。

  对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会很大概率非顺序访问，而不是像快速排序那样，局部顺序访问。这样对 CPU 缓存是不友好的。

- 对于同样的数据，在排序过程中，**堆排序算法的数据交换次数要多于快速排序**。

  快速排序数据交换的次数不会比逆序度多。堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。



# 非基于比较的排序算法

## 桶排序

O(n) = nlog(n/m)，m表示桶的个数。要成为O(n)，n/m要尽量小，也即桶要多并且桶内数据要均匀。

### 算法要点

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

### 适用场景

- 要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。
- 数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

举例：10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。

### 时间复杂度

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序/归并排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

### 稳定性

每个桶使用稳定排序算法，那桶排序就是稳定的；每个桶使用非稳定排序算法，那桶排序就是非稳定的。



## 计数排序

**桶的数据范围是1**的桶排序。

### 算法要点

计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

计数排序的算法思想跟桶排序非常类似，只是桶的大小粒度不一样。

### 适用场景

- 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
- 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

举例：有 50 万考生，通过成绩快速排序得出名次。根据年龄给 100 万用户排序。

### 时间复杂度

因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。

### 稳定性

稳定。



## 基数排序

**从“低位”到“高位”**，依次进行**多次线性排序**。

### 算法要点

基数排序把数据分割出独立的“位”来比较，每个“位”的排序使用线性排序算法，每个“位”的排序算法要稳定。

### 适用场景

- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
- 除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

举例：有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序。

### 时间复杂度

根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。

### 稳定性

稳定。



# 综合对比

|              | 空间复杂度是否O(1) | 是否稳定 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 |
| ------------ | ------------------ | -------- | -------------- | -------------- | -------------- |
| 冒泡排序     | 是                 | 是       | O(n)           | O(n^2)         | O(n^2)         |
| **插入排序** | 是                 | 是       | O(n)           | O(n^2)         | O(n^2)         |
| 选择排序     | 是                 | 不是     | O(n^2)         | O(n^2)         | O(n^2)         |
| **归并排序** | 不是，O(n)         | 是       | O(nlogn)       | O(nlogn)       | O(nlogn)       |
| **快速排序** | 是                 | 不是     | O(nlogn)       | O(n^2)         | O(nlogn)       |
| **堆排序**   | 是                 | 不是     | O(nlogn)       | O(nlogn)       | O(nlogn)       |
|              |                    |          |                |                |                |
| 桶排序       | 否                 | 是       | 不再区分，O(n) |                |                |
| 计数排序     | 否                 | 是       | 不再区分，O(n) |                |                |
| 基数排序     | 否                 | 是       | 不再区分，O(n) |                |                |

基本不使用选择排序（插入排序比它优秀），堆排序（需要稳定的场景，使用归并排序；需要空间的场景，快速排序比它移动的元素少）。

小规模的数据，使用O(n^2)的算法，首选插入排序，因为挪动数组元素只需要一步，冒泡中的交换数组元素需要三步。

大规模的数据，使用O(nlogn)。

- 对空间有要求，稳定性没要求，快排排序。
- 对空间没要求，稳定性有要求，归并排序。
- 既要求空间，又要求稳定，只能插入排序。

特殊的数据，使用线性排序。



Glibc 中的 qsort() 函数：

- qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。
- 要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。
- 在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。
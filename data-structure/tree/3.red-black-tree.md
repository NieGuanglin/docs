[TOC]

# 2-3树

## 定义

2-3树是二叉查找树的变种，树中的2和3代表两种节点。在这两种节点的配合下，2-3树可以保证：任意叶子节点到根节点的距离都是相同的。

- 2-节点

  即普通节点，包含1个元素，两条子链接。

- 3-节点

  则是扩充版，包含2个元素和三条链接。

  两个元素A、B，左边的链接指向小于A的节点，中间的链接指向介于A、B值之间的节点，右边的链接指向大于B的节点。



## 从2-3树到红黑树

2-3树的设计完全可以保证二叉树保持矮矮胖胖的状态，保持其性能良好。但是，将这种直白的表述写成代码实现起来并不方便，因为要将链接和其他信息从一个节点复制到另一个节点，将节点从一种类型转换为另一种类型等等。

因此，红黑树出现了，红黑树的背后逻辑就是2-3树的逻辑，但是由于用红黑颜色对节点进行抽象，实现起来相对比较容易。

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/data-structure/tree/r-b-tree/1.从2-3树到红黑树的演进.png">

<img src="/Users/nieguanglin/docs/pics/data-structure/tree/r-b-tree/1.从2-3树到红黑树的演进.png" alt="从2-3树到红黑树的演进" style="zoom:100%;" />



平衡二叉树的严格定义，也即“原教旨主义”的定义：二叉树中任意一个节点的左右子树的高度相差不能大于 1。AVL树就是遵守这个定义，但是相应的，维护成本就比较高。

红黑树使用红、黑颜色，对节点进行抽象；对严格的定义进行妥协。换来两个好处：

- 代码实现，相对比较容易。
- 树的平衡性，相对比较平衡，即”完美黑色平衡”。

因此，红黑树得以在工程中普遍使用。



# 红黑树

## 定义

1. **颜色**：节点的颜色，要么为红色，要么为黑色。
2. **根**：根节点为黑色。
3. **叶**：所有叶节点，都是一个不存储数据的，颜色为黑色的，nil节点。
4. **连续红**：红色节点的父、子节点都不能是红色。也即，不存在两个相邻的红色节点。
5. **黑色平衡**：任意节点，到达它可以到达的任意叶节点，经过的黑色节点数相等。



## 操作

### 旋转

#### 左旋

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/data-structure/tree/r-b-tree/2.红黑树左旋操作.png">

<img src="/Users/nieguanglin/docs/pics/data-structure/tree/r-b-tree/2.红黑树左旋操作.png" alt="红黑树左旋操作" style="zoom:100%;" />

#### 右旋

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/data-structure/tree/r-b-tree/3.红黑树右旋操作.png">

<img src="/Users/nieguanglin/docs/pics/data-structure/tree/r-b-tree/3.红黑树右旋操作.png" alt="红黑树右旋操作" style="zoom:100%;" />

### 查找

红黑树是平衡二叉查找树的一种实现，所以它的查找逻辑与二叉查找树相同。



### 插入

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/data-structure/tree/r-b-tree/4.红黑树插入操作流程图.png">

<img src="/Users/nieguanglin/docs/pics/data-structure/tree/r-b-tree/4.红黑树插入操作流程图.png" alt="红黑树插入操作流程图" style="zoom:100%;" />

红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。

#### 插入步骤

1. 为空树，新增节点为root，颜色变为black。结束。
2. 指定root为当前节点。
3. 小于当前节点的值：
   1. 当前节点的左孩子为nil：新增节点插到当前节点的左孩子；跳出循环。
   2. 当前节点的左孩子不为nil：当前节点变更为当前节点的左孩子；循环3-5步。
4. 大于当前节点的值：
   1. 当前节点的右孩子为nil：新增节点插到当前节点的右孩子；跳出循环。
   2. 当前节点的右孩子不为nil：当前节点变更为当前节点的右孩子；循环3-5步。
5. 等于当前节点的值：值已在树中；结束。

#### 调整步骤

1. 插入节点为red且插入节点的父节点为red，否则直接结束。
   1. 获取uncle节点。
   2. uncle节点不为nil，且为red
      -  插入节点parent，uncle变black
      - 插入节点的祖父节点作为新插入节点
      - 插入节点为root，或为nil，结束
      - 插入节点变为red。继续从最外层的第1步开始判断。
   3. uncle节点为nil，或者不为nil且为black（定义的第三条，对于代码的简化意义，这里就体现了）
      - 插入节点的parent位于插入节点的祖父的left
        - 插入节点位于插入节点的parent的right：
        - 插入节点位于插入节点的parent的left：
        - 综合调整：
      -  插入节点的parent位于插入节点的祖父的right



### 删除



## 时间复杂度

最不理想的情况下，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。

最理想的情况下，二叉查找树是一棵完全二叉树，所以查找的时间复杂度就变成了 O(logn)。

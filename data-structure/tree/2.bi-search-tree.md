[TOC]

# 二插查找树

## 定义

二插查找树，也叫做二插搜索树，二插排序树。

## 时间复杂度

最不理想的情况下，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。

最理想的情况下，二叉查找树是一棵完全二叉树，所以查找的时间复杂度就变成了 O(logn)。

## 操作

### 查找

1. 先取根节点，如果它等于要查找的数据，就返回。
2. 如果要查找的数据比根节点的值小，那就在左子树中递归查找。
3. 如果要查找的数据比根节点的值大，那就在右子树中递归查找。

### 插入

1. 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。
2. 同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

### 删除

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/data-structure/tree/bi-search-tree/1.二叉搜索树的删除操作.png">

<img src="/Users/nieguanglin/pics/data-structure/tree/bi-search-tree/1.二叉搜索树的删除操作.png" alt="二叉搜索树的删除操作" style="zoom:100%;" />

1. 如果要删除的节点没有子节点。

   只需要将父节点中，指向要删除节点的指针置为 null。

2. 如果要删除的节点只有一个子节点（只有左子节点或者右子节点）。

   只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。

3. 如果要删除的节点有两个子节点。

   需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。

   然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，最小节点要么没有子节点，要么只有一个右子节点，可以应用上面两条规则来删除这个最小节点。

### 修改

1. 先删除。
2. 再插入。

## 与散列表的对比

散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那为什么还要用二叉查找树呢？

- 有序。散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
- 效率。尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，加上哈希函数的耗时，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。
- 复杂。散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
[TOC]

# 二分查找

## 算法要点

- low，high，mid三个索引游标。

  根据mid索引的值与给定值的大小关系，调整low，或调整high，或返回。

- 循环退出条件
  注意是 low<=high，而不是 low<high.
  因为若数据的长度为偶数，查找操作的倒数第二步，low会等于high，故比较运算符选择 <= 。 不然，查找操作将被中断。

- mid 的取值
  实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。
  更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。

- low 和 high 的更新
  low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。
  比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。



## 时间复杂度

### 数组的二分查找

每一次缩小操作只涉及两个数据的大小比较，而数组的按索引访问时间复杂度是O(1)，所以时间复杂度就与数组的缩小次数有关。

```
被查找区间的大小变化：
n, n/2, n/4, n/8, ..., n/2^k, ...
```

可以看出来，这是一个等比数列。其中 n/2^k=1 时，k 的值就是总共缩小的次数。

通过 n/2^k=1，求得 k=log2n，所以时间复杂度就是 **O(logn)**。

### 链表的二分查找

每一次缩小操作，还要伴随着遍历元素，所以时间复杂度就与总共遍历的元素个数有关。

```
假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):
第一次查找中间点，需要移动指针n/2次；
第二次，需要移动指针n/4次；
第三次需要移动指针n/8次；
......
以此类推，一直到1次为止。
```

总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + ...+ 1，这显然是个等比数列。

```
等比数列通项：
an = a1*q^(n-1)
等比数列求和：
Sum = a1(1 - q^n) / (1 - q)

因为an= a1*q^(n-1) = 1
sum = (n/2 - 1/2) / 1/2
    = n - 1
```

最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同。

但是在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢。



## 适用场景

- 二分查找依赖的是数组。

  不能依赖链表。主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。

- 二分查找针对的是有序数据。

  二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。针对动态数据集合，在其中快速查找某个数据，需要用到二叉树。

- 数据量太小不适合二分查找。

  如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。

- 据量太大也不适合二分查找。

  二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。

举例：

- 假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？



## 二分查找的扩展

### 查找第一个值等于给定值的元素

### 查找最后一个值等于给定值的元素

### 查找第一个大于等于给定值的元素

### 查找最后一个小于等于给定值的元素

适用举例：

- 假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？
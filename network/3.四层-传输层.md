[TOC]

# UDP

## UDP的特性

MAC层定义了本地局域网的传输行为，IP层定义了整个网络端到端的传输行为，这两层基本定义了这样的情况：网络传输是以包为单位的，二层叫帧，三层叫包，四层叫段。笼统称它们为包，包单独传输，自行选路，在不同的设备封装解封装，不保证到达。UDP就完全继承了这些特性。

## TCP与UDP的区别

- TCP是面向连接的。在互通之前，面向连接的协议会先建立连接。**所谓的建立连接，就是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证面向连接的特性。**

  UDP是面向无连接的。

- TCP提供可靠交付，通过TCP连接传输的数据，<u>无差错，不丢失，不重复，按序到达</u>。

  UDP继承了IP包的特性，不保证不丢失，不保证按序到达。

- TCP是面向字节流的。发送的时候发的是一个流，没头没尾。IP包不是一个流，而是一个一个的IP包。之所以变成了流，这是TCP状态维护做的事情。

  UDP继承了IP的特性，基于数据报，一个一个地发，一个一个地收。

- TCP有拥塞控制。它意识到包丢弃或者网络环境不好，就会根据情况调整自己的行为：是不是发快了？要不要发慢点？

  UDP就不会做拥塞控制。

## UDP报文格式

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/udp/1udp-udp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">

<img src="/Users/nieguanglin/docs/pics/network/udp/1udp-udp报文格式.png" alt="1udp-udp报文格式" style="zoom:100%;" />

无论是TCP还是UDP，报文头都应该有源端口号和目的端口号，根据目的端口号区分应用程序，将数据交给相应的应用程序。

## UDP的特点

- 简单，不需要大量的数据结构、处理逻辑、包头字段。
- 无连接，它虽然有端口号，但谁都可以给它传数据，它也可以给任何人传数据，甚至可以同时传给多个人数据。
- 无拥塞控制，不会根据网络的情况进行发包的拥塞控制，无论网络丢包多么严重，它还是该怎么发就怎么发。

## 使用UDP的场景

- 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。

  DHCP就是基于UDP的。

- 不需要一对一沟通，不需要建立连接，可以广播的应用。

  UDP的不面向连接的功能，可以承载广播或者多播的协议。

  DHCP就是一种广播的形式，基于UDP。

  VXLAN需要用到组播，也是基于UDP。使用组播地址，可以将包组播给一批机器。

- 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也一往无前的时候。

  很多应用都是要求低时延的，它们不想要TCP复杂的机制，而是根据自己的场景，实现自己的可靠和连接保证。例如，有些应用认为，有的包丢了就丢了，没必要重传。有的包比较重要，那么应用自己重传，不依赖TCP；前面的包没到，后面的包到了，就可以展示给用户，没必要等到齐；网络不好，要尽快传，要挤占带宽，抢在用户失去耐心之前到达。

## 巧妙使用UDP的例子

- QUIC（Quick UDP Internet Connections）

  Google提出的一种基于UDP改进的通信协议，其目的是降低网络通信延迟，提供更好的用户体验。QUIC在应用层上，自己实现快速连接建立，减少重传时延，自适应拥塞控制。

- 流媒体协议

  直播协议多使用RTMP，它基于TCP。在网络不好的时候，TCP的按序到达控制，会导致视频卡顿。直播的实时性比较重要，宁可丢包，也不要卡顿；对于丢包，应用可以选择性的丢掉部分视频帧；TCP的拥塞控制会主动降低发送速度，但是应用在应用层应该马上重传，挤占带宽，而不是主动让步。

  所以，很多视频应用，都基于UDP实现了自己的视频传输协议。

- 实时游戏

  实时游戏，采用自定义的可靠UDP协议，自定义重传策略，把丢包产生的延迟降到最低，尽量减少网络问题对游戏造成的影响。

- IoT物联网

  物联网领域终端资源少，而维护TCP协议的代价太大。Google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，基于UDP协议。



# TCP

## TCP报文格式

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/1tcp-tcp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">

<img src="/Users/nieguanglin/docs/pics/network/tcp/1tcp-tcp报文格式.png" alt="1tcp-tcp报文格式" style="zoom:100%;" />

- 端口：**一条TCP连接是由四元组标识的，分别是源IP，源PORT，目的IP，目的PORT。一旦一个元素发生变化，就需要断开连接，重新连接。**

- 序列号（seq）：32bit，seq就是这个报文段的第一个字节的数据编号，用来标记数据段的顺序。TCP把连接中发送的所有数据字节都编上一个序号，数据字节有序号后，就可以给每一个报文段指派一个序号。

- 确认号（ack）：32bit，告诉对方，期待下一次接收的seq。

- 数据偏移：4bit，TCP首部（包括选项）长度除以4。

- 标志位：6bit。
  - URG：1表示紧急指针域有效，用来保证TCP连接不被中断，并督促中间层设备要尽快处理这些数据。
  - **ACK**：1表示ack确认号有效。
  - PSH：1表示Push操作，数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区排队。
  - RST：1表示复位TCP连接，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包。
  - **SYN**：1表示这是一个连接请求或连接接收报文。
  - **FIN**：用来释放一个连接。FIN=1时：此报文段的发送方的数据已经发送完毕,并要求释放连接。
  
- 窗口大小：16bit，TCP做流量控制，通信双方各声明一个窗口，标识自己当前能够处理的能力。

- 校验和：16bit。

- 紧急指针：16bit。

## 连接维护

TCP中，对于收到的每个包，都会有一个回复的包告知对端收到了。这个回复的包，不能与上层的http响应搞混。

### 三次握手

- 过程：

  ​	<img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/2tcp-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">

  <img src="/Users/nieguanglin/docs/pics/network/tcp/2tcp-tcp三次握手.png" alt="2tcp-tcp三次握手" style="zoom:100%;" />

  1. 客户端发送syn包（SYN=1，seq=x）到服务器，进入**SYN_SENT**状态，等待服务器确认。
  2. 服务端收到syn包，必须进行确认，同时自己也发送一个syn包（SYN=1， ACK=1， seq=y， ack=x+1）,服务器进入**SYN_RCVD**状态。
  3. 客户端收到服务端的syn+ack包，向服务端发送确认（ACK=1，seq=x+1，ack=y+1）。

- 为什么不是两次握手，不是四次握手，而是三次握手？

  三次握手有两个重要的功能，1要双方做好发送数据的准备，而且双方都知道彼此已经准备好；2要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。两次握手的话，就会缺少一次确认的过程。

  客户端发送给服务端的应答之应答（也就是第三次握手）也会丢，按理来说还应该有一个应答之应答之应答（也就是第四次握手）。但是这样下去就没尽头了，所以更多次握手是可以的，但即使更多次握手，也不能真正保证可靠。好在大部分情况下，建立连接后，客户端会马上发送数据给服务端。一旦发送数据，则很多问题都得到解决。例如，客户端发给服务端的应答丢了，当客户端后续发送的数据到达时，服务端就可以认为这个连接已经建立。或者服务端挂了，客户端发送的数据没有得到响应，客户端也就知道连接断开了。

- 如果已经建立了连接，但是客户端突然出现故障怎么办？

  TCP设有保活计时器，服务端每收到一个客户端的请求都会复位这个计时器。如果定时时间到还没有收到客户端到任何请求，服务端会发送一个探测报文。如果一连发送10个探测报文仍然没有反应，服务端就会关闭连接。

### 四次挥手

- 过程：

  ​	<img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/3tcp-tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">

  <img src="/Users/nieguanglin/docs/pics/network/tcp/3tcp-tcp四次挥手.png" alt="3tcp-tcp四次挥手" style="zoom:100%;" />

  1. 客户端发送连接释放报文，并且停止发送数据（FIN=1，seq=u），客户端进入**FIN_WAIT_1**状态。

  2. 服务端收到连接释放报文，发送确认报文（ACK=1，ack=u+1），服务端进入**CLOSE_WAIT**（关闭等待）状态。

  3. 服务端将最后的数据发送完毕后，向客户端发送连接释放报文（FIN=1，ACK=1，ack=u+1，seq=w），服务端进入**LAST_ACK**状态，等待客户端的确认。

  4. 客户端收到服务端的连接释放报文后，必须发出确认（ACK=1，ack=w+1）。客户端进入**TIME_WAIT**状态.

     经过2*MSL（Maximum Segment Lifetime，报文段最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃）的时间后，在此期间没有收到服务端的超时重发FIN报文，那么断开连接。

- 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

  假设网络不可靠，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

  如果服务端没收到ACK，客户端将不断重发ACK。

  所以客户端不能立即关闭，它需要确认服务端收到了。怎么确认？

  客户端设置一个定时器，时长为2\*MSL，如果这段时间再次收到服务端的FIN，说明服务端之前没收到ACK。那就重发ACK再等待2*MSL。如果这段时间没再收到服务端的FIN，说明服务端之前收到了ACK，则结束TCP连接。

#### MSL

Maximum Segment Lifetime，报文最大生存时间。它指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。协议默认MSL为2分钟，实际常用30秒，1分钟和2分钟。

IP头中有一个TTL字段，是IP数据报可以经过的最大路由数，每经过一个路由它的TTL减1，当为0时则数据报被丢弃，同时发送ICMP报文通知源主机。

### HTTP请求响应中的TCP流

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/3-1tcp-http%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84tcp%E6%B5%81.png">

<img src="/Users/nieguanglin/docs/pics/network/tcp/3-1tcp-http请求中的tcp流.png" alt="3-1tcp-http请求中的tcp流" style="zoom:100%;" />

- 为什么挥手过程只有三个包，而不是四个？

  这是因为服务端收到客户端的FIN后，服务端同时也要关闭连接，于是ACK和FIN合并到一起了，节省了一个包。

  通常情况下，服务端收到客户端的FIN后，很可能还没有发送完数据，于是先回复一个ACK。等发送完所有数据后，才会发送FIN。这时就是四次挥手了。

## 顺序问题和丢包问题

确认与重发的机制
- 为了保证顺序性，每一个包都有一个ID。在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送。
- 为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的ID，表示在此ID之前的包都收到了，这种模式称为**累计应答**。

### 超时重试

对每一个发送了，但是没有ACK的包，都设有一个定时器，超过了定时时间就重新尝试。这个超时时间如何评估呢？它不宜过短，时间必须大于往返**RTT**，否则会引起不必要的重传；它不宜过长，这样超时时间变长，访问就变慢了。

估计往返时间，需要通过采样RTT的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样RTT，还要采样RTT的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，因此称为**自适应重传算法**。而且，每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

### 快速重传

超时触发重传存在的问题是，超时周期可能较长，所以有一个快速重传的机制。当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的ACK，仍然ACK的是期望接收的报文段。当客户端收到三个冗余的ACK后，就会在定时器过期之前，重传丢失的报文段。

## 流量控制

### 滑动窗口

接收端会给发送端回复一个窗口的大小，叫做Advertised Window。通过**滑动窗口**的大小，来限制发送端可发送量，进而流量控制。

- 发送方缓冲队列

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/4tcp-%E5%8F%91%E9%80%81%E6%96%B9%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97.png">

  <img src="/Users/nieguanglin/docs/pics/network/tcp/4tcp-发送方缓冲队列.png" alt="4tcp-发送方缓冲队列" style="zoom:100%;" />

  - LastByteAcked：发送已确认和发送未确认的分界线。
  - LastByteSent：发送未确认和未发送可发送的分界线。
  - LastByteAcked + AdvertisedWindow：未发送可发送和未发送不可发送的分界线。

- 接收方缓冲队列

  <img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/5tcp-%E6%8E%A5%E6%94%B6%E6%96%B9%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97.png">

  <img src="/Users/nieguanglin/docs/pics/network/tcp/5tcp-接收方缓冲队列.png" alt="5tcp-接收方缓冲队列" style="zoom:100%;" />
  
  - NextByteExpected：接收已确认和等待接收未确认的分界线。
  - 第二部分的大小：最大缓存量 - 已经接收确认但是还没被应用层读取的部分。接收方会将第二部分的大小，作为Advertised Window发送给发送方，发送方就可以根据它调整发送速度了。

## 拥塞控制

### 拥塞窗口，congestion window

滑动窗口rwnd是怕发送方把接收方缓存塞满，而**拥塞窗口**cwnd是怕把网络塞满。拥塞窗口和滑动窗口共同控制发送的速度。
$$
LastByteSent - LastByteAcked <= min\{cwnd, rwnd\}
$$
拥塞控制主要用来避免两种情况，包丢失和超时重传。

### 慢启动，slow start

<img src="https://github.com/NieGuanglin/docs/blob/main/pics/network/tcp/6tcp%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E6%85%A2%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png">

<img src="/Users/nieguanglin/docs/pics/network/tcp/6tcp拥塞窗口慢启动过程.png" alt="6tcp拥塞窗口慢启动过程" style="zoom:100%;" />

#### 传统算法对应超时重传

cwnd先指数增长，再线性增长。拥塞的表现形式是丢包，需要超时重传，一旦出现拥塞，则衰减到0。然后重复这个周期。

这种方式太激进，将一个高速的传输速度一下子停下来，会造成网络卡顿。

#### 快速恢复对应快速重传

一旦拥塞，进行快速重传。TCP认为情况不严重，只丢了小部分，于是cwnd不衰减到0，而是折半，继续在高位线性增长。

### BBR拥塞算法

拥塞窗口的慢启动，使得时延很重要的情况下，反而降低了速度。

TCP BBR拥塞算法，它企图找到一个平衡点，通过不断地加快发送速度，将网络填满，但是不要填中间设备的缓存，因为这样时延会增加。在这个平衡点可以很好的达到高带宽和低时延的平衡。
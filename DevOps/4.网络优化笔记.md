[TOC]

# 网络性能指标

## 带宽

链路的最大传输速率，单位通常为bit/s。

## 吞吐量

单位时间内成功传输的数据量，单位通常为bit/s或者Byte/s。吞吐量受带宽限制，而吞吐量/带宽，也就是该网络的使用率。

## 延时

从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同的场景中，这一指标可能会有不同含义。比如，建立连接需要的时间（TCP握手延迟）。一个数据包往返所需要的时间（RTT）。

## PPS

Packet Per Second，也即包/s，表示以网络包为单位的传输速率。PPS通常用来评估网络的转发能力。比如，硬件交换机通常可以达到线性转发，PPS可以达到或者接近理论最大值。基于Linux服务器的转发，则容易受网络包大小的影响。

## 网络可用性

网络能否正常通信。

## 并发连接数

TCP连接数。

## 丢包率

丢包百分比。

## 重传率

重新传输的网络包比例。



# Index

## ifconfig，ip

查看网络配置。

```bash
$ ifconfig eth1
$ ip -s addr show dev eth1
```

输出的结果中，TX和RX部分：

- errors：发生错误的数据包数，比如校验错误，帧同步错误等。
- dropped：丢弃的数据包数，即数据包已经收到了Ring Buffer，但因为内存不足等原因丢包。
- overruns：超限数据包数，即网络i/o速度过快，导致Ring Buffer中的数据包来不及处理，队列满而导致的丢包。
- carrier：发生carrier错误的数据包数，比如双工模式不匹配，物理电缆出现问题等。
- collisions：碰撞数据包数。

## netstat，ss

查看socket信息。

```bash
$ netstat -nlpt
$ ss -nlpt
```

-n：显示数字地址和端口，而不是名字

-l：只显示监听socket

-p：显示进程信息

-t：只显示tcp socket

输出的结果中，接收队列Recv-Q和发送队列Send-Q，在socket不同状态下，含义不同：

1. 当socket处于Established时

   - Recv-Q：接收队列长度。
   - Send-Q：发送队列长度。

2. 当socket处于Listen时

   - Recv-Q：全连接队列的长度。
   - Send-Q：全连接队列的最大长度。

   > 全连接，服务端收到客户端的ack，完成tcp三次握手，然后把这个socket放在全连接队列。这些全连接队列中的socket，还需要被accept系统调用取走，服务端才可以开始真正处理客户端的请求。
   >
   > 半连接，服务端收到客户端的syn，然后把这个socket放在半连接队列，之后再向客户端发送syn+ack。这时候，tcp三次握手还没有完成。

## sar

查看网络吞吐和PPS。

```bash
$ sar -n Dev 1
```

## ping

连通性和延时。

```bash
$ ping -c3 xxx.xxx.xxx.xxx
```

-c3：发送三次ICMP包后停止

## nslookup，dig

排查DNS解析问题。

## tcpdump

抓包分析。

```bash
$ tcpdump [-option] [expression]
```

常用option

| option | example              | explain                                                      |
| ------ | -------------------- | ------------------------------------------------------------ |
| -i     | tcpdump -i eth0      | 指定网络接口，默认是eth0。any表示所有接口。                  |
| -n     | tcpdump -n           | 对主机以数字方式显示，否则显示为主机名。也就是说避免DNS查询。 |
| -nn    | tcpdump -nn          | 除了-n的作用外，端口也显示数值。                             |
| -c     | tcpdump -c5          | 限制要抓取网络包的个数。                                     |
| -A     | tcpdump -A           | 以ASCII格式显示网络包内容，不指定时只显示头部信息。          |
| -e     | tcpdump -e           | 输出链路层的头部信息。                                       |
| -w     | tcpdump -w file.pcap | 保存到文件中，文件后缀通常是.pcap。                          |

常用expression

| expression                           | example                       | explain    |
| ------------------------------------ | ----------------------------- | ---------- |
| host，src host，dst host             | tcpdump -nn host 192.168.10.1 | 主机过滤   |
| net，src net，dst net                | tcpdump -nn net 192.168.0.0   | 网络过滤   |
| port，port range，src port，dst port | tcpdump -nn dst port 80       | 端口过滤   |
| arp。ip，ip6，icmp。tcp，udp         | tcpdump -nn tcp               | 协议过滤   |
| and，or，not                         | tcpdump -nn icmp or udp       | 逻辑表达式 |

## Wireshark

网络抓包和图形界面分析工具。



# C10K

C10K就是单机同时处理10k个请求（并发连接10k）的问题。如果不使用IO多路复用，就要创建10k个进程或线程，那么操作系统是无法承受的。

而**IO多路复用，是指一个线程维护多个socket（也即，多个IO连接，复用一个线程）**。

## select，poll

某个线程负责的所有socket，都放在一个文件描述符集合中。调用select，或poll函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符，找出可读或可写的socket，从而进行读写操作。然后再调用select，或poll函数进行下一轮的监听。

select，poll还有一些限制。select使用固定长度的位相量，表示文件描述符集合，因此会有最大数量的限制。poll改进了select的表示方法，换成了一个没有固定长度的数组，这样就没有最大数量的限制（当然还会受到系统文件描述符的限制）。

但是，无论select，还是poll，都需要对文件描述符列表进行轮询，这大大影响了线程能够维护的最大连接数。

## epoll

epoll函数在内核中的实现不是通过轮询的方式，而是通过注册callback函数的方式。当某个文件描述符发生变化时，进行主动通知。

而且，epoll使用红黑树，在内核中管理文件描述符集合。这样线程能够同时监听的socket数就非常多了，上限就是系统定义的，允许进程打开的最大文件描述符的个数。

## 扩展

### C1000K

C1000K的解决方法，本质还是构建在epoll配合线程池的基础上。只不过，除了I/O模型之外，还需要从应用程序到Linux内核，再到cpu，内存和网络等各个层次的深度优化。特别是需要借助硬件，来卸载那些原来通过软件处理的大量工作。

比如，大量请求带来的中断处理，会带来非常高的处理成本。这就需要多队列网卡，中断负载均衡，cpu绑定，RPS/RFS（软中断负载均衡到多个cpu核上），以及将网络包的处理卸载到网络设备等各种硬件和软件的优化。

### C10M

DPDK机制，是用户态网络的标准。它跳过内核协议栈，直接由用户态进程进行轮询的方式，来处理网络接收。

- 在PPS非常高的场景，查询时间比实际工作时间少了很多，绝大部分时间都在处理网络包，所以轮询并不低效。
- 跳过内核协议栈后，就省去了硬中断，软中断再到Linux网络协议栈逐层处理的过程，应用程序可以有针对性的优化处理逻辑。
- DPDK还通过大页，cpu绑定，内存对齐，流水线并发等多种机制，优化网络包的处理效率。

当然，在实际场景中，并不需要单机并发10 000 000的请求。可以通过调整系统架构，把这些请求分发到多台服务器中来处理。